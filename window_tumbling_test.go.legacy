package streamz

import (
	"github.com/zoobzio/clockz"
	"context"
	"fmt"
	"sync"
	"testing"
	"time"
)

func TestTumblingWindow_BasicFunctionality(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewTumblingWindow[int](100*time.Millisecond, clock)
	out := window.Process(ctx, in)

	var results []Result[int]
	var wg sync.WaitGroup

	// Collect results with window metadata
	wg.Add(1)
	go func() {
		defer wg.Done()
		for result := range out {
			results = append(results, result)
		}
	}()

	// Send test data with timing
	go func() {
		defer close(in)

		// Send 3 items in first window period
		for i := 1; i <= 3; i++ {
			in <- NewSuccess(i)
			clock.Advance(30 * time.Millisecond) // 30ms between items
		}

		// Trigger first window emission
		clock.Advance(40 * time.Millisecond) // Total: 100ms
		clock.BlockUntilReady()              // Let goroutine process

		// Send 2 more items in second window
		for i := 4; i <= 5; i++ {
			in <- NewSuccess(i)
			clock.Advance(40 * time.Millisecond)
		}

		// Trigger second window emission
		clock.Advance(20 * time.Millisecond) // Complete second window
		clock.BlockUntilReady()
	}()

	wg.Wait()

	if len(results) != 5 {
		t.Fatalf("expected 5 results, got %d", len(results))
	}

	// Validate all results have window metadata
	for i, result := range results {
		if !result.IsSuccess() {
			t.Errorf("result %d: expected success, got error", i)
		}
		
		meta, err := GetWindowMetadata(result)
		if err != nil {
			t.Errorf("result %d: failed to get window metadata: %v", i, err)
		}
		
		if meta.Type != "tumbling" {
			t.Errorf("result %d: expected window type 'tumbling', got %s", i, meta.Type)
		}
		
		if meta.Size != 100*time.Millisecond {
			t.Errorf("result %d: expected window size 100ms, got %v", i, meta.Size)
		}
	}

	// Validate first window results (items 1, 2, 3)
	firstWindowResults := results[:3]
	for i, result := range firstWindowResults {
		expected := i + 1
		if result.Value() != expected {
			t.Errorf("first window result %d: expected value %d, got %d", i, expected, result.Value())
		}
	}

	// Validate second window results (items 4, 5)
	secondWindowResults := results[3:]
	for i, result := range secondWindowResults {
		expected := i + 4
		if result.Value() != expected {
			t.Errorf("second window result %d: expected value %d, got %d", i, expected, result.Value())
		}
	}
}

func TestTumblingWindow_WithErrors(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewTumblingWindow[int](100*time.Millisecond, clock).WithName("test-window")
	out := window.Process(ctx, in)

	// Collect results and aggregate them using WindowCollector
	collector := NewWindowCollector[int]()
	collections := collector.Process(ctx, out)

	var windows []WindowCollection[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range collections {
			windows = append(windows, w)
		}
	}()

	go func() {
		defer close(in)

		// Mix of success and errors
		in <- NewSuccess(1)
		in <- NewError(2, fmt.Errorf("processing failed"), "test")
		in <- NewSuccess(3)
		in <- NewError(4, fmt.Errorf("validation failed"), "test")

		// Trigger window emission
		clock.Advance(100 * time.Millisecond)
		clock.BlockUntilReady()
	}()

	wg.Wait()

	if len(windows) != 1 {
		t.Fatalf("expected 1 window, got %d", len(windows))
	}

	w := windows[0]
	if w.Count() != 4 {
		t.Errorf("expected 4 total items, got %d", w.Count())
	}
	if w.SuccessCount() != 2 {
		t.Errorf("expected 2 successes, got %d", w.SuccessCount())
	}
	if w.ErrorCount() != 2 {
		t.Errorf("expected 2 errors, got %d", w.ErrorCount())
	}

	// Check successful values
	values := w.Values()
	if len(values) != 2 || values[0] != 1 || values[1] != 3 {
		t.Errorf("expected values [1, 3], got %v", values)
	}

	// Check errors
	errors := w.Errors()
	if len(errors) != 2 {
		t.Errorf("expected 2 errors, got %d", len(errors))
	}
	if errors[0].Item != 2 {
		t.Errorf("first error: expected item 2, got %v", errors[0].Item)
	}
	if errors[1].Item != 4 {
		t.Errorf("second error: expected item 4, got %v", errors[1].Item)
	}
}

func TestTumblingWindow_EmptyWindows(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewTumblingWindow[int](100*time.Millisecond, clock)
	out := window.Process(ctx, in)

	var windows []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			windows = append(windows, w)
		}
	}()

	go func() {
		defer close(in)

		// Send item in first window
		in <- NewSuccess(1)
		clock.Advance(100 * time.Millisecond)
		clock.BlockUntilReady()

		// Let empty window pass (no items in second window)
		clock.Advance(100 * time.Millisecond)
		clock.BlockUntilReady()

		// Send item in third window
		in <- NewSuccess(2)
		clock.Advance(100 * time.Millisecond)
		clock.BlockUntilReady()
	}()

	wg.Wait()

	// Should only get 2 windows (empty windows are not emitted)
	if len(windows) != 2 {
		t.Fatalf("expected 2 windows, got %d", len(windows))
	}

	if windows[0].Values()[0] != 1 {
		t.Errorf("first window: expected value 1, got %v", windows[0].Values())
	}
	if windows[1].Values()[0] != 2 {
		t.Errorf("second window: expected value 2, got %v", windows[1].Values())
	}
}

func TestTumblingWindow_ContextCancellation(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewTumblingWindow[int](time.Second, clock)
	out := window.Process(ctx, in)

	var windows []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			windows = append(windows, w)
		}
	}()

	go func() {
		defer close(in) // Ensure channel is closed
		
		// Send some data
		in <- NewSuccess(1)
		clock.BlockUntilReady() // Wait for item to be processed
		in <- NewSuccess(2)
		clock.BlockUntilReady() // Wait for item to be processed

		// Cancel context
		cancel()
	}()

	wg.Wait()

	// Should emit current window with partial data
	if len(windows) != 1 {
		t.Fatalf("expected 1 window on cancellation, got %d", len(windows))
	}
	if windows[0].Count() != 2 {
		t.Errorf("expected 2 items in canceled window, got %d", windows[0].Count())
	}
}

func TestTumblingWindow_InputChannelClose(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewTumblingWindow[int](time.Second, clock)
	out := window.Process(ctx, in)

	var windows []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			windows = append(windows, w)
		}
	}()

	go func() {
		// Send some data and close input
		in <- NewSuccess(1)
		in <- NewSuccess(2)
		close(in)
	}()

	wg.Wait()

	// Should emit current window with partial data
	if len(windows) != 1 {
		t.Fatalf("expected 1 window on input close, got %d", len(windows))
	}
	if windows[0].Count() != 2 {
		t.Errorf("expected 2 items in final window, got %d", windows[0].Count())
	}
}

func TestTumblingWindow_WindowTimeBoundaries(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	baseTime := time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC)
	clock := clockz.NewFakeClockAt(baseTime)
	window := NewTumblingWindow[int](100*time.Millisecond, clock)
	out := window.Process(ctx, in)

	var windows []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			windows = append(windows, w)
		}
	}()

	go func() {
		defer close(in)

		in <- NewSuccess(1)
		clock.Advance(100 * time.Millisecond)
		time.Sleep(10 * time.Millisecond)
	}()

	wg.Wait()

	if len(windows) != 1 {
		t.Fatalf("expected 1 window, got %d", len(windows))
	}

	w := windows[0]
	expectedStart := baseTime
	expectedEnd := baseTime.Add(100 * time.Millisecond)

	if !w.Start.Equal(expectedStart) {
		t.Errorf("window start: expected %v, got %v", expectedStart, w.Start)
	}
	if !w.End.Equal(expectedEnd) {
		t.Errorf("window end: expected %v, got %v", expectedEnd, w.End)
	}
}

func TestTumblingWindow_Name(t *testing.T) {
	clock := clockz.NewFakeClock()
	window := NewTumblingWindow[int](time.Second, clock)

	if window.Name() != "tumbling-window" {
		t.Errorf("default name: expected 'tumbling-window', got '%s'", window.Name())
	}

	window = window.WithName("custom-window")
	if window.Name() != "custom-window" {
		t.Errorf("custom name: expected 'custom-window', got '%s'", window.Name())
	}
}

func TestTumblingWindow_RealClock_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	in := make(chan Result[string])
	window := NewTumblingWindow[string](50*time.Millisecond, RealClock)
	out := window.Process(ctx, in)

	var windows []Window[string]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			windows = append(windows, w)
		}
	}()

	go func() {
		defer close(in)

		// Send items with real timing
		for i := 0; i < 10; i++ {
			in <- NewSuccess(fmt.Sprintf("item-%d", i))
			time.Sleep(20 * time.Millisecond)
		}
		// Let final window emit
		time.Sleep(60 * time.Millisecond)
	}()

	wg.Wait()

	// Should get multiple windows based on real timing
	if len(windows) < 2 {
		t.Errorf("expected at least 2 windows with real timing, got %d", len(windows))
	}

	totalItems := 0
	for _, w := range windows {
		totalItems += w.Count()
	}
	if totalItems != 10 {
		t.Errorf("expected 10 total items across windows, got %d", totalItems)
	}
}
