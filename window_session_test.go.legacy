package streamz

import (
	"github.com/zoobzio/clockz"
	"context"
	"fmt"
	"sync"
	"testing"
	"time"
)

func TestSessionWindow_BasicSessionCreation(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewSessionWindow[int](
		func(r Result[int]) string {
			if r.IsSuccess() {
				return "user1"
			}
			return "user1" // For this test, all items belong to same session
		},
		clock,
	).WithGap(100 * time.Millisecond)

	out := window.Process(ctx, in)

	var sessions []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			sessions = append(sessions, w)
		}
	}()

	go func() {
		defer close(in)

		// Send first item to start session
		in <- NewSuccess(1)

		// Wait for processing
		time.Sleep(10 * time.Millisecond)

		// Add more items to extend session
		in <- NewSuccess(2)
		clock.Advance(50 * time.Millisecond)
		in <- NewSuccess(3)

		// Wait for session to expire
		clock.Advance(200 * time.Millisecond) // More than gap duration
		clock.BlockUntilReady()              // Allow ticker to process
	}()

	wg.Wait()

	if len(sessions) != 1 {
		t.Fatalf("expected 1 session, got %d", len(sessions))
	}

	session := sessions[0]
	values := session.Values()
	if len(values) != 3 {
		t.Fatalf("expected 3 values in session, got %d", len(values))
	}

	expected := []int{1, 2, 3}
	for i, v := range values {
		if v != expected[i] {
			t.Errorf("expected value %d at index %d, got %d", expected[i], i, v)
		}
	}

	if session.Count() != 3 {
		t.Errorf("expected count 3, got %d", session.Count())
	}

	if session.SuccessCount() != 3 {
		t.Errorf("expected success count 3, got %d", session.SuccessCount())
	}

	if session.ErrorCount() != 0 {
		t.Errorf("expected error count 0, got %d", session.ErrorCount())
	}
}

func TestSessionWindow_MultipleSessionsWithDifferentKeys(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[string])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewSessionWindow[string](
		func(r Result[string]) string {
			if r.IsSuccess() {
				return r.Value() // Use the value itself as session key
			}
			return "error-session"
		},
		clock,
	).WithGap(100 * time.Millisecond)

	out := window.Process(ctx, in)

	var sessions []Window[string]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			sessions = append(sessions, w)
		}
	}()

	go func() {
		defer close(in)

		// Create first session for "user1"
		in <- NewSuccess("user1")
		clock.Advance(25 * time.Millisecond)

		// Create second session for "user2"
		in <- NewSuccess("user2")
		clock.Advance(25 * time.Millisecond)

		// Extend first session
		in <- NewSuccess("user1")
		clock.Advance(25 * time.Millisecond)

		// Wait for sessions to expire
		clock.Advance(200 * time.Millisecond)
		clock.BlockUntilReady()
	}()

	wg.Wait()

	if len(sessions) != 2 {
		t.Fatalf("expected 2 sessions, got %d", len(sessions))
	}

	// Check that we have sessions for both users
	user1Count := 0
	user2Count := 0

	for _, session := range sessions {
		values := session.Values()
		if len(values) > 0 {
			if values[0] == "user1" {
				user1Count = len(values)
			} else if values[0] == "user2" {
				user2Count = len(values)
			}
		}
	}

	if user1Count != 2 {
		t.Errorf("expected user1 session to have 2 items, got %d", user1Count)
	}

	if user2Count != 1 {
		t.Errorf("expected user2 session to have 1 item, got %d", user2Count)
	}
}

func TestSessionWindow_SessionExtensionResetsTimeout(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewSessionWindow[int](
		func(_ Result[int]) string { return "session1" },
		clock,
	).WithGap(100 * time.Millisecond)

	out := window.Process(ctx, in)

	var sessions []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			sessions = append(sessions, w)
		}
	}()

	go func() {
		defer close(in)

		// Start session
		in <- NewSuccess(1)

		// Advance time but not enough to expire
		clock.Advance(80 * time.Millisecond)

		// Extend session - this should reset the timeout
		in <- NewSuccess(2)

		// Advance time again - still shouldn't expire
		clock.Advance(80 * time.Millisecond)

		// Add one more item
		in <- NewSuccess(3)

		// Now let it expire
		clock.Advance(150 * time.Millisecond)
		clock.BlockUntilReady()
	}()

	wg.Wait()

	if len(sessions) != 1 {
		t.Fatalf("expected 1 session, got %d", len(sessions))
	}

	session := sessions[0]
	if session.Count() != 3 {
		t.Errorf("expected session to have 3 items, got %d", session.Count())
	}
}

func TestSessionWindow_ErrorsInSessions(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewSessionWindow[int](
		func(r Result[int]) string {
			if r.IsSuccess() {
				return "user1"
			}
			// Extract key from error context - in real usage you'd have this info
			return "user1"
		},
		clock,
	).WithGap(100 * time.Millisecond)

	out := window.Process(ctx, in)

	var sessions []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			sessions = append(sessions, w)
		}
	}()

	go func() {
		defer close(in)

		// Mix of success and errors in same session
		in <- NewSuccess(1)
		clock.Advance(25 * time.Millisecond)

		in <- NewError(2, context.DeadlineExceeded, "test-processor")
		clock.Advance(25 * time.Millisecond)

		in <- NewSuccess(3)
		clock.Advance(25 * time.Millisecond)

		in <- NewError(4, context.Canceled, "test-processor")

		// Wait for session to expire
		clock.Advance(150 * time.Millisecond)
		clock.BlockUntilReady()
	}()

	wg.Wait()

	if len(sessions) != 1 {
		t.Fatalf("expected 1 session, got %d", len(sessions))
	}

	session := sessions[0]

	if session.Count() != 4 {
		t.Errorf("expected total count 4, got %d", session.Count())
	}

	if session.SuccessCount() != 2 {
		t.Errorf("expected success count 2, got %d", session.SuccessCount())
	}

	if session.ErrorCount() != 2 {
		t.Errorf("expected error count 2, got %d", session.ErrorCount())
	}

	values := session.Values()
	if len(values) != 2 || values[0] != 1 || values[1] != 3 {
		t.Errorf("expected values [1, 3], got %v", values)
	}

	errors := session.Errors()
	if len(errors) != 2 {
		t.Errorf("expected 2 errors, got %d", len(errors))
	}
}

func TestSessionWindow_ContextCancellation(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewSessionWindow[int](
		func(_ Result[int]) string { return "session1" },
		clock,
	).WithGap(100 * time.Millisecond)

	out := window.Process(ctx, in)

	var sessions []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			sessions = append(sessions, w)
		}
	}()

	// Send items to create a session
	in <- NewSuccess(1)
	in <- NewSuccess(2)

	// Small delay to allow the items to be processed by the SessionWindow
	time.Sleep(25 * time.Millisecond)

	// Cancel the context to trigger session emission
	cancel()

	// Allow time for cancellation to propagate and sessions to be emitted
	time.Sleep(100 * time.Millisecond)

	// Close the input channel to ensure complete cleanup
	close(in)

	wg.Wait()

	if len(sessions) != 1 {
		t.Fatalf("expected 1 session (should emit on cancel), got %d", len(sessions))
	}

	session := sessions[0]
	if session.Count() != 2 {
		t.Errorf("expected session to have 2 items, got %d", session.Count())
	}
}

func TestSessionWindow_InputChannelClosed(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewSessionWindow[int](
		func(_ Result[int]) string { return "session1" },
		clock,
	).WithGap(100 * time.Millisecond)

	out := window.Process(ctx, in)

	var sessions []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			sessions = append(sessions, w)
		}
	}()

	go func() {
		// Start session
		in <- NewSuccess(1)
		in <- NewSuccess(2)

		// Close input channel
		close(in)
	}()

	wg.Wait()

	if len(sessions) != 1 {
		t.Fatalf("expected 1 session (should emit on close), got %d", len(sessions))
	}

	session := sessions[0]
	if session.Count() != 2 {
		t.Errorf("expected session to have 2 items, got %d", session.Count())
	}
}

func TestSessionWindow_EmptySession(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewSessionWindow[int](
		func(_ Result[int]) string { return "session1" },
		clock,
	).WithGap(100 * time.Millisecond)

	out := window.Process(ctx, in)

	var sessions []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			sessions = append(sessions, w)
		}
	}()

	go func() {
		// Close input immediately without sending anything
		close(in)
	}()

	wg.Wait()

	if len(sessions) != 0 {
		t.Errorf("expected 0 sessions for empty input, got %d", len(sessions))
	}
}

func TestSessionWindow_ConfigurationMethods(t *testing.T) {
	clock := clockz.NewFakeClock()

	window := NewSessionWindow[int](
		func(_ Result[int]) string { return "key" },
		clock,
	)

	// Test default values
	if window.gap != 30*time.Minute {
		t.Errorf("expected default gap 30m, got %v", window.gap)
	}

	if window.name != "session-window" {
		t.Errorf("expected default name 'session-window', got %q", window.name)
	}

	// Test WithGap
	window = window.WithGap(5 * time.Minute)
	if window.gap != 5*time.Minute {
		t.Errorf("expected gap 5m, got %v", window.gap)
	}

	// Test WithName
	window = window.WithName("custom-session")
	if window.name != "custom-session" {
		t.Errorf("expected name 'custom-session', got %q", window.name)
	}

	// Test Name() method
	if window.Name() != "custom-session" {
		t.Errorf("expected Name() to return 'custom-session', got %q", window.Name())
	}
}

func TestSessionWindow_VeryShortGap(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewSessionWindow[int](
		func(_ Result[int]) string { return "session1" },
		clock,
	).WithGap(5 * time.Millisecond) // Very short gap

	out := window.Process(ctx, in)

	var sessions []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			sessions = append(sessions, w)
		}
	}()

	go func() {
		defer close(in)

		// Send item
		in <- NewSuccess(1)

		// Wait for session to expire (ticker should use minimum 10ms)
		clock.Advance(50 * time.Millisecond)
		clock.BlockUntilReady()
	}()

	wg.Wait()

	if len(sessions) != 1 {
		t.Fatalf("expected 1 session, got %d", len(sessions))
	}

	session := sessions[0]
	if session.Count() != 1 {
		t.Errorf("expected session to have 1 item, got %d", session.Count())
	}
}

func TestSessionWindow_LongRunningSession(t *testing.T) {
	ctx := context.Background()
	in := make(chan Result[int])

	clock := clockz.NewFakeClockAt(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC))
	window := NewSessionWindow[int](
		func(_ Result[int]) string { return "session1" },
		clock,
	).WithGap(100 * time.Millisecond)

	out := window.Process(ctx, in)

	var sessions []Window[int]
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for w := range out {
			sessions = append(sessions, w)
		}
	}()

	go func() {
		defer close(in)

		// Keep session alive by sending items regularly
		for i := 1; i <= 10; i++ {
			in <- NewSuccess(i)
			// Advance less than gap duration to keep session alive
			clock.Advance(80 * time.Millisecond)
			clock.BlockUntilReady()
		}

		// Now let session expire
		clock.Advance(150 * time.Millisecond)
		clock.BlockUntilReady()
	}()

	wg.Wait()

	if len(sessions) != 1 {
		t.Fatalf("expected 1 session, got %d", len(sessions))
	}

	session := sessions[0]
	if session.Count() != 10 {
		t.Errorf("expected session to have 10 items, got %d", session.Count())
	}

	values := session.Values()
	for i, v := range values {
		if v != i+1 {
			t.Errorf("expected value %d at index %d, got %d", i+1, i, v)
		}
	}
}

// Benchmarks to verify performance characteristics.
func BenchmarkSessionWindow_SingleSession(b *testing.B) {
	clock := clockz.NewFakeClock()
	window := NewSessionWindow[int](
		func(_ Result[int]) string { return "session1" },
		clock,
	).WithGap(100 * time.Millisecond)

	for n := 0; n < b.N; n++ {
		ctx, cancel := context.WithCancel(context.Background())
		in := make(chan Result[int])
		out := window.Process(ctx, in)

		// Consumer goroutine
		go func() {
			//nolint:revive // empty-block: intentional channel draining
			for range out {
				// Drain output
			}
		}()

		// Send items
		go func() {
			defer close(in)
			for i := 0; i < 100; i++ {
				in <- NewSuccess(i)
			}
		}()

		// Let it process briefly then cancel
		time.Sleep(time.Millisecond)
		cancel()
	}
}

func BenchmarkSessionWindow_MultipleSessions(b *testing.B) {
	clock := clockz.NewFakeClock()
	window := NewSessionWindow[int](
		func(r Result[int]) string {
			if r.IsSuccess() {
				return fmt.Sprintf("session%d", r.Value()%10) // 10 different sessions
			}
			return "error-session"
		},
		clock,
	).WithGap(100 * time.Millisecond)

	for n := 0; n < b.N; n++ {
		ctx, cancel := context.WithCancel(context.Background())
		in := make(chan Result[int])
		out := window.Process(ctx, in)

		// Consumer goroutine
		go func() {
			//nolint:revive // empty-block: intentional channel draining
			for range out {
				// Drain output
			}
		}()

		// Send items to different sessions
		go func() {
			defer close(in)
			for i := 0; i < 100; i++ {
				in <- NewSuccess(i) // Will be distributed across 10 sessions
			}
		}()

		// Let it process briefly then cancel
		time.Sleep(time.Millisecond)
		cancel()
	}
}
