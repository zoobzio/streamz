---
title: Overview
description: Type-safe stream processing pipelines for Go channels
author: zoobzio
published: 2025-01-09
updated: 2025-01-09
tags:
  - overview
  - introduction
---

# Overview

Stream processing in Go means managing channels, goroutines, and backpressure manually.

streamz provides composable processors that handle channel lifecycle, error propagation, and flow control automatically.

```go
type Processor[In, Out any] interface {
    Process(ctx context.Context, in <-chan Result[In]) <-chan Result[Out]
    Name() string
}
```

Each processor transforms an input channel into an output channel. Chain them together to build pipelines.

```go
// Filter -> Transform -> Batch
filter := streamz.NewFilter(isValid).WithName("validate")
mapper := streamz.NewMapper(enrich).WithName("enrich")
batcher := streamz.NewBatcher[Order](streamz.BatchConfig{
    MaxSize:    100,
    MaxLatency: 5 * time.Second,
})

// Compose the pipeline
filtered := filter.Process(ctx, orders)
enriched := mapper.Process(ctx, filtered)
batched := batcher.Process(ctx, enriched)
```

Type-safe, minimal dependencies, automatic channel cleanup.

## Philosophy

streamz treats streams as first-class citizens. Processors are small, focused units that combine into complex behaviors. Every processor implements the same interface, creating a uniform abstraction across your entire data flow.

```go
// All processors compose the same way
buffered := buffer.Process(ctx, input)
throttled := throttle.Process(ctx, buffered)
monitored := monitor.Process(ctx, throttled)
batched := batcher.Process(ctx, monitored)
```

No configuration objects. No framework lock-in. Just composition.

## Capabilities

**[Transformation](./5.reference/1.api.md)** - Filter, map, and aggregate data flowing through channels. Synchronous or concurrent processing with order preservation.

**[Batching](./5.reference/1.api.md)** - Accumulate items by count, time, or both. Efficient database writes and API calls.

**[Flow Control](./5.reference/1.api.md)** - Throttle throughput, debounce bursts, buffer spikes. Handle backpressure without losing data.

**[Windowing](./5.reference/1.api.md)** - Tumbling, sliding, and session windows for time-based aggregation.

**[Error Handling](./2.learn/7.error-handling.md)** - Dead letter queues, retry with backoff, circuit breakers. Errors flow through pipelines as data.

**[Routing](./5.reference/1.api.md)** - Fan-out to multiple consumers, fan-in from multiple sources, partition by key or round-robin.

streamz provides the composition layer. What you build on top is up to you.

## Priorities

### Type Safety

Generics eliminate runtime type assertions. Data flows through pipelines with compile-time checking at every step.

```go
// Compile-time type checking
filter := streamz.NewFilter(func(o Order) bool {
    return o.Total > 100 // o is Order, not interface{}
})

// Type mismatch caught at compile time
// filter.Process(ctx, stringChannel) // Won't compile
```

### Composability

Small processors combine into complex behaviors. Each processor serves one purpose and combines cleanly with others.

```go
// Layer flow control
resilient := streamz.NewBuffer[Order](10000)
throttled := streamz.NewThrottle[Order](100, time.Second)
monitored := streamz.NewMonitor[Order](time.Second)

// Compose freely
buffered := resilient.Process(ctx, input)
limited := throttled.Process(ctx, buffered)
observed := monitored.Process(ctx, limited)
```

### Error Context

Errors carry context through the pipeline. Know exactly where failures occurred and what data was being processed.

```go
for result := range output {
    if result.IsError() {
        err := result.Error()
        fmt.Printf("Failed at: %s\n", err.ProcessorName)
        fmt.Printf("Item: %+v\n", err.Item)
        fmt.Printf("Cause: %v\n", err.Err)
    }
}
```

### Testability

Inject fake clocks for deterministic testing of time-based processors. No flaky tests, no sleep calls.

```go
clock := clockz.NewFakeClock()
window := streamz.NewTumblingWindow[int](time.Minute, clock)

// Control time in tests
clock.Advance(time.Minute)
```

## Start Here

- **[Getting Started](./2.learn/1.quickstart.md)** - Build your first pipeline in 10 minutes
- **[Core Concepts](./2.learn/2.concepts.md)** - Understand the fundamentals
- **[API Reference](./5.reference/1.api.md)** - Complete processor documentation
